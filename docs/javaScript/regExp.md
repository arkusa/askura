# RegExp

## 模式

- `g`

全局匹配, 匹配出所有的符合正则规则的字符/字符串

```javaScript
const reg = /\d/g;

'1234567890qwer'.match(reg);
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]

'1234567890qwer'.match(/\d/);
/*
 * {
 *   0: 1,
 *   index: 0,
 *   ...
 * }
 */
```

## 元字符

### 数量

- `{n}`

n个

- `{n,}`

大于等于n个

- `{n,m}`

大于等于n, 小于等于m

- `+`

大于等于1个, 相当于`{1,}`

- `*`

大于等于0个, 相当于`{0,}`

### 数字

- `\d`

0-9的数字

- `\D`

非`\d`

### 单词边界

- `\b`

单词边界

- `\B`

非单词边界

### 断言

- `(?=)`

正向断言, 表示匹配后面是`xx`的`x`

举个🌰
```javaScript
/a(?=b)/

意思是匹配后面是b的a

'acb' // 这样🙅, ab要紧邻
```

### 结尾

## 应用实🌰

- **银行记数字的方式, 比如我的存款是1.000.000.000.000.000.000**

思路是从后面向前查, 每查到3的倍数就加一个`.`

因为正则是对字符串从前向后查找的

所以对上面的思路翻译一下就是**从头开始查找匹配空字符，什么样的空字符呢？他的后面的数字个数是3的正整数倍, 并且这个空字符不能是单词边界**

所以这里我们用到了`正向断言`, `非单词边界`, `{n}`, `+`, `g`

```javaScript
const reg = /\B(?=(\d{3})+$)/g;
// \B 非单词边界
// \B(?=\d{3}) 后面有3个数字并且不是单词边界的字符 // 10000 会被匹配为 1.0000 或者 1.0.000, 看是否加g 因为1(这里后面有4个数字当然包括3个了)0000, 同理 ...
// \B(?=(\d{3})+) 后面有3的正整数倍个数字且不是单词边界的字符
// \B(?=(\d{3})+$) 到结尾后面有3的正整数被个数字且不是单词字符
// /\B(?=(\d{3})+$)/g 全局匹配
let numberStr = '10000000';
console.log(numberStr.replace(numberStr, '.'));
```
